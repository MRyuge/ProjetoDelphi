unit HttpClientUtils;

interface

uses
  System.SysUtils, System.Classes, IdHTTP, IdSSLOpenSSL, System.JSON;

type
  THttpClientUtils = class
  private

  public
    FBaseUrl: string;
    class function GetBaseUrl: string;
    class function Get(const URL: string): TJSONValue; static;
    class function Post(const URL: string; const Body: TJSONObject)
      : TJSONValue; static;
    class function Put(const URL: string; const Body: TJSONObject)
      : TJSONValue; static;

    class function Delete(const URL: string): TJSONValue; static;
    constructor Create;
  end;

implementation

uses
  IniFiles;

constructor THttpClientUtils.Create;
var
  IniFilePath: string;
  IniFile: TIniFile;
begin
  // Ajuste o caminho para encontrar o arquivo no local correto
  IniFilePath := ExtractFilePath(ParamStr(0)) + '..\..\Config\AppConfig.ini';
  // Caminho relativo

  // Verifica se o arquivo INI existe
  if not FileExists(IniFilePath) then
    raise Exception.Create('Arquivo AppConfig.ini não encontrado em: ' +
      IniFilePath);

  // Lê o arquivo INI
  IniFile := TIniFile.Create(IniFilePath);
  try
    FBaseUrl := IniFile.ReadString('Server', 'BaseUrl', '');
    if FBaseUrl.Trim.IsEmpty then
      raise Exception.Create
        ('A URL do servidor não foi configurada no arquivo AppConfig.ini.');
  finally
    IniFile.Free;
  end;
end;

class function THttpClientUtils.GetBaseUrl: string;
var
  IniFile: TIniFile;
  IniFilePath: string;
begin
  // Ajusta para sempre procurar a pasta Config no diretório do projeto
  IniFilePath := ExtractFilePath(ParamStr(0)) + '..\..\Config\AppConfig.ini';

  // Verifica se o arquivo INI existe
  if not FileExists(IniFilePath) then
    raise Exception.Create('Arquivo AppConfig.ini não encontrado em: ' +
      IniFilePath);

  IniFile := TIniFile.Create(IniFilePath);
  try
    Result := IniFile.ReadString('Server', 'BaseUrl', '');
    if Result.IsEmpty then
      raise Exception.Create('BaseUrl não configurado no AppConfig.ini');
  finally
    IniFile.Free;
  end;
end;

class function THttpClientUtils.Get(const URL: string): TJSONValue;
var
  HTTP: TIdHTTP;
  SSLHandler: TIdSSLIOHandlerSocketOpenSSL;
  ResponseString: string;
begin
  HTTP := TIdHTTP.Create(nil);
  SSLHandler := TIdSSLIOHandlerSocketOpenSSL.Create(nil);
  try
    HTTP.IOHandler := SSLHandler;
    HTTP.Request.ContentType := 'application/json';

    try
      // Realiza a requisição GET
      ResponseString := HTTP.Get(URL);

      // Verifica se a resposta não está vazia
      if ResponseString.Trim.IsEmpty then
        raise Exception.Create('Resposta vazia recebida do servidor.');

      // Converte a resposta em TJSONValue
      Result := TJSONObject.ParseJSONValue(ResponseString);

      // Verifica se a conversão foi bem-sucedida
      if not Assigned(Result) then
        raise Exception.Create('Falha ao converter a resposta para JSON.');

    except
      on E: Exception do
        raise Exception.Create('Erro ao realizar requisição GET: ' + E.Message);
    end;

  finally
    HTTP.Free;
    SSLHandler.Free;
  end;
end;

class function THttpClientUtils.Post(const URL: string; const Body: TJSONObject)
  : TJSONValue;
var
  HTTP: TIdHTTP;
  SSLHandler: TIdSSLIOHandlerSocketOpenSSL;
  RequestBody: TStringStream;
  ResponseString: string;
begin
  HTTP := TIdHTTP.Create(nil);
  SSLHandler := TIdSSLIOHandlerSocketOpenSSL.Create(nil);
  RequestBody := TStringStream.Create(Body.ToString, TEncoding.UTF8);
  try
    HTTP.IOHandler := SSLHandler;
    HTTP.Request.ContentType := 'application/json';

    // Realiza a requisição POST
    ResponseString := HTTP.Post(URL, RequestBody);

    // Converte a resposta em TJSONValue
    Result := TJSONObject.ParseJSONValue(ResponseString);
  finally
    HTTP.Free;
    SSLHandler.Free;
    RequestBody.Free;
  end;
end;

class function THttpClientUtils.Put(const URL: string; const Body: TJSONObject)
  : TJSONValue;
var
  HTTP: TIdHTTP;
  SSLHandler: TIdSSLIOHandlerSocketOpenSSL;
  RequestBody: TStringStream;
  ResponseString: string;
begin
  HTTP := TIdHTTP.Create(nil);
  SSLHandler := TIdSSLIOHandlerSocketOpenSSL.Create(nil);
  RequestBody := TStringStream.Create(Body.ToString, TEncoding.UTF8);
  try
    HTTP.IOHandler := SSLHandler;
    HTTP.Request.ContentType := 'application/json';

    // Realiza a requisição PUT
    ResponseString := HTTP.Put(URL, RequestBody);

    // Converte a resposta em TJSONValue
    Result := TJSONObject.ParseJSONValue(ResponseString);
  finally
    HTTP.Free;
    SSLHandler.Free;
    RequestBody.Free;
  end;
end;

class function THttpClientUtils.Delete(const URL: string): TJSONValue;
var
  HTTPClient: THTTPClient;
  Response: IHTTPResponse;
  ResponseString: string;
begin
  HTTPClient := THTTPClient.Create;
  try
    // Configura o tipo de conteúdo para a requisição
    HTTPClient.ContentType := 'application/json';

    // Envia a requisição DELETE
    try
      Response := HTTPClient.Delete(URL); // Envia a requisição DELETE
      ResponseString := Response.ContentAsString;
      // Obtém a resposta como string

      // Verifica se a resposta não está vazia
      if ResponseString.Trim.IsEmpty then
        raise Exception.Create('Resposta vazia recebida do servidor.');

      // Converte a resposta em TJSONValue
      Result := TJSONObject.ParseJSONValue(ResponseString);

      // Verifica se a resposta é um JSON válido
      if not Assigned(Result) then
        raise Exception.Create('Resposta não é um JSON válido.');

    except
      on E: Exception do
        raise Exception.Create('Erro ao realizar requisição DELETE: ' +
          E.Message);
    end;

  finally
    HTTPClient.Free;
  end;
end;

end.
